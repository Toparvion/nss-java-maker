package ru.toparvion.security.njm;

import ru.toparvion.security.njm.proc.DhLogTreeProcessor;
import ru.toparvion.security.njm.proc.LogTreeProcessor;
import ru.toparvion.security.njm.proc.RsaLogTreeProcessor;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.*;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Stream;

/**
 * Main class of the utility. Contains entry point method main().
 * "Puzzle" is an internal title of the utility project.
 */
public class Puzzle {
  private static final Logger logger = Logger.getLogger(Puzzle.class.getName());
  private static final String PROGRAM_TITLE = String.format("%s v%s",
          Puzzle.class.getPackage().getImplementationTitle(),
          Puzzle.class.getPackage().getImplementationVersion());

  public static void main(String[] args) throws Exception {
    System.out.println(PROGRAM_TITLE);
    if (args.length < 1) {
      System.out.println(USAGE_HINT);
      return;
    }

    String input = args[args.length - 1];
    if (input.toLowerCase().startsWith("-out:") || input.toLowerCase().startsWith("-outmode:")) {
      throw new IllegalArgumentException("Input log file is not specified. Please specify it" +
              " with the -in: option, e.g. -in:somedir/ssl.log.");
    }

    String output = Stream.of(args)
            .filter(s -> s.toLowerCase().startsWith("-out:"))
            .map(s -> s.substring("-out:".length()))
            .findFirst()
            .orElse("session-keys.nss");

    OutMode outMode = Stream.of(args)
            .filter(s -> s.toLowerCase().startsWith("-outmode:"))
            .map(s1 -> s1.substring("-outmode:".length()).toUpperCase())
            .filter(s2 ->
                    Stream.of(OutMode.values())
                            .map(Enum::name)
                            .filter(name -> name.equalsIgnoreCase(s2))
                            .findFirst()
                            .isPresent())
            .map(OutMode::valueOf)
            .findFirst()
            .orElse(OutMode.SKIP);

    logger.info(String.format("Program start params:\ninput log file: '%s',\noutput NSS file: '%s'," +
                    "\noutput file mode: %s.", input, output, outMode));

    new Puzzle(input, output, outMode);

  }

  private Puzzle(String input, String output, OutMode outMode) throws Exception {
    // get in and out file paths
    Path logPath = getLogPath(input);
    Path nssPath = getNssPath(output, outMode);

    // build a tree for convenient content processing
    LogTree logTree = parseLogToTree(logPath);

    // detect the encrypting mode used in the session
    boolean isDhMode = logTree.get("ServerKeyExchange", null).isPresent();

    // select and instantiate log tree processor
    LogTreeProcessor processor;
    if (isDhMode) {
      logger.info("Log recognized mode: Diffie-Hellman.");
      processor = new DhLogTreeProcessor();
    } else {
      logger.info("Log recognized mode: RSA.");
      processor = new RsaLogTreeProcessor();
    }

    // make the processor produce NSS file entry
    NssFileEntry nssFileEntry = processor.process(logTree);
    logger.fine("Composed NSS file entry:\n" + nssFileEntry);

    // compose new NSS file lines
    List<String> nssLines = Arrays.asList(
      String.format("# SSL/TLS secrets log file, generated by %s (%s)", PROGRAM_TITLE, new Date().toString()),
      nssFileEntry.toString()
    );

    // output the results in chosen mode
    Files.write(nssPath, nssLines, outMode.openOptions);
    logger.info("SSL/TLS keys successfully extracted and exported to NSS file: " + output);
  }

  /**
   * Reads log file and fills a 3-level tree with its content.
   */
  private LogTree parseLogToTree(Path logPath) throws IOException {
    LogTree logTree = new LogTree();
    Files.lines(logPath)
            .forEach(token -> {
              if (LogTree.PREDICATE_LEVEL_1.test(token)) {
                Node newNodeLevel_1 = new Node(token);
                logTree.nodesLevel_1.add(newNodeLevel_1);
                logTree.root.getChildren().add(newNodeLevel_1);
                return;
              }

              if (LogTree.PREDICATE_LEVEL_2.test(token)) {
                if (!logTree.nodesLevel_1.isEmpty()) {
                  Node newNodeLevel_2 = new Node(token);
                  logTree.nodesLevel_2.add(newNodeLevel_2);
                  logTree.nodesLevel_1.getLast().getChildren().add(newNodeLevel_2);
                } else {
                  logger.fine(String.format("String '%s' has no parent node and thus will be skipped.", token));
                }
                return;
              }

              if (LogTree.PREDICATE_LEVEL_3.test(token)) {
                if (!logTree.nodesLevel_2.isEmpty()) {
                  Node newNodeLevel_3 = new Node(token);
                  logTree.nodesLevel_3.add(newNodeLevel_3);
                  logTree.nodesLevel_2.getLast().getChildren().add(newNodeLevel_3);
                } else {
                  logger.fine(String.format("String '%s' has no parent node and thus will be skipped.", token));
                }
                return;
              }

              logger.warning(String.format("Line '%s' hasn't matched to any log tree level " +
                      "and will be skipped.", token));
            });
    return logTree;
  }

  private static Path getLogPath(String log) throws FileNotFoundException {
    Path logPath = Paths.get(log);
    if (Files.notExists(logPath) || !Files.isReadable(logPath)) {
      throw new FileNotFoundException(String.format("No log file found in '%s' or it is not accessible for reading.",
              logPath.toString()));
    }
    return logPath;
  }

  private static Path getNssPath(String nss, OutMode outMode) {
    Path nssPath = Paths.get(nss);
    if (OutMode.SKIP.equals(outMode) && Files.exists(nssPath)) {
      throw new IllegalArgumentException(String.format("File '%s' already exists. Please choose another output file" +
              " (with -out: option) or set another output mode, e.g. REWRITE or APPEND, with -outMode: option", nss));
    }
    return nssPath;
  }

  /**
   * Enumeration of supported output modes. Every mode includes corresponding OpenOption to use in file handling.
   */
  private static enum OutMode {
    APPEND    (StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.APPEND),
    REWRITE   (StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING),
    SKIP;

    OutMode(OpenOption... openOptions) {
      this.openOptions = openOptions;
    }

    OpenOption[] openOptions;
  }

  private static final String USAGE_HINT = "Usage: NssJavaMaker.jar [opts] <path/to/java/ssl/log.file>\n" +
          "Where 'opts':\n" +
          "-out:path/to/result.nss - specifies the path to export the results to, defaults to 'session-keys.nss' in current directory;\n" +
          "                          example: -out:export/session-5.nss;\n" +
          "-outMode:<SKIP|APPEND|REWRITE> - specifies file access mode for exporting results, defaults to SKIP (don't export at all);\n" +
          "                          example: -outMode:APPEND";
}
